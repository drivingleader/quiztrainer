<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SYNAPSE - Drive Core</title>
    <style>
        /* --- RESET & VARIABLES --- */
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-glass: rgba(24, 24, 27, 0.7);
            --primary: #22d3ee; /* Cyan */
            --primary-glow: rgba(34, 211, 238, 0.4);
            --accent: #c084fc; /* Purple */
            --success: #4ade80;
            --error: #f43f5e;
            --text: #e4e4e7;
            --text-dim: #71717a;
            --font-main: 'Inter', system-ui, -apple-system, sans-serif;
            --font-mono: 'JetBrains Mono', 'Courier New', monospace;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* --- UI LAYER --- */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; /* Let clicks pass to canvas/game */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
            padding: 1.5rem;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        .brand {
            font-family: var(--font-mono);
            font-weight: 800;
            letter-spacing: -0.05em;
            font-size: 1.5rem;
            color: var(--text);
        }
        .brand span { color: var(--primary); }

        .stats {
            display: flex;
            gap: 1rem;
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .stat-item b { color: var(--text); margin-right: 4px; }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 4px;
            background: #27272a;
            border-radius: 2px;
            margin-top: 1rem;
            position: relative;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.5s cubic-bezier(0.22, 1, 0.36, 1);
            box-shadow: 0 0 10px var(--primary);
        }

        /* Footer / Context Info */
        .footer {
            text-align: center;
            pointer-events: auto;
        }
        .context-chip {
            background: var(--surface-glass);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 0.75rem;
            color: var(--text-dim);
            display: inline-block;
            margin-bottom: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            font-family: var(--font-mono);
        }
        .tutorial-hint {
            color: var(--text-dim);
            font-size: 0.8rem;
            opacity: 0.6;
            margin-bottom: 5px;
            animation: pulse 2s infinite;
        }

        /* --- GAME LAYER --- */
        #game-container {
            position: absolute;
            inset: 0;
            z-index: 1;
            overflow: hidden;
            touch-action: none;
            background: radial-gradient(circle at center, #131316 0%, #09090b 100%);
        }

        /* Nodes (DOM elements for better text handling) */
        .node {
            position: absolute;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: 1rem;
            transition: transform 0.1s, box-shadow 0.3s;
            cursor: pointer;
            will-change: transform, left, top;
        }

        .node-core {
            width: 140px;
            height: 140px;
            background: rgba(10, 10, 10, 0.8);
            border: 2px solid var(--primary);
            box-shadow: 0 0 30px var(--primary-glow);
            z-index: 5;
            color: white;
            font-weight: 700;
            font-size: 0.95rem;
            padding: 1rem;
            border-radius: 50%; /* Circle */
        }

        .node-option {
            max-width: 160px;
            padding: 0.8rem 1.2rem;
            background: var(--surface);
            border: 1px solid #3f3f46;
            color: var(--text);
            font-size: 0.85rem;
            z-index: 4;
            border-radius: 1rem; /* Rounded Rect */
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            user-select: none;
        }

        .node-option.connected {
            border-color: var(--success);
            background: rgba(74, 222, 128, 0.1);
            color: var(--success);
        }

        .node-option.wrong {
            border-color: var(--error);
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        /* --- CANVAS --- */
        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 2; /* Below nodes */
        }

        /* --- ANIMATIONS --- */
        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 0.8; } 100% { opacity: 0.4; } }
        @keyframes shake {
            10%, 90% { transform: translate(-52%, -50%); }
            20%, 80% { transform: translate(-48%, -50%); }
            30%, 50%, 70% { transform: translate(-54%, -50%); }
            40%, 60% { transform: translate(-46%, -50%); }
        }

        /* Overlay Messages */
        .overlay-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: 3rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 20;
            text-transform: uppercase;
            font-family: var(--font-mono);
        }
        .overlay-msg.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .text-success { color: var(--success); text-shadow: 0 0 30px rgba(74, 222, 128, 0.6); }
        .text-error { color: var(--error); text-shadow: 0 0 30px rgba(244, 63, 94, 0.6); }

    </style>
</head>
<body>

    <!-- UI LAYER -->
    <div class="ui-layer">
        <div>
            <div class="header">
                <div class="brand">SYNAPSE<span>.</span></div>
                <div class="stats">
                    <div class="stat-item"><b id="score-display">0</b> PTS</div>
                    <div class="stat-item" style="color:var(--primary)"><b id="streak-display">0</b> STREAK</div>
                </div>
            </div>
            <div class="progress-container">
                <div id="progress-bar" class="progress-fill"></div>
            </div>
        </div>

        <div class="footer">
            <div id="tutorial-txt" class="tutorial-hint">Collega le affermazioni VERE al nucleo centrale</div>
            <div id="context-chip" class="context-chip">CARICAMENTO DATI...</div>
        </div>
    </div>

    <!-- GAME MESSAGES -->
    <div id="msg-overlay" class="overlay-msg"></div>

    <!-- GAME CONTAINER -->
    <div id="game-container">
        <canvas id="connections-canvas"></canvas>
        <!-- Nodes injected here via JS -->
    </div>

    <script>
        /* * =========================================
         * DATA ENGINE
         * =========================================
         */
        
        // This is a subset of the uploaded file for demonstration. 
        // In a real scenario, this string would contain the full text content.
        const RAW_DATA = `
Argomento: La strada
La strada è...
[ F ] ...riservata alla circolazione dei soli autoveicoli e motocicli
[ V ] ...aperta alla circolazione dei pedoni, degli animali e dei veicoli
[ F ] ...qualsiasi area asfaltata, limitata lateralmente dagli attraversamenti pedonali
La strada è normalmente...
[ F ] ...riservata alla circolazione dei soli veicoli e animali
La strada può...
[ V ] ...comprendere le piste ciclabili
[ V ] ...essere suddivisa in carreggiate
[ V ] ...essere a doppio senso di circolazione
[ V ] ...essere a senso unico di circolazione
La strada non comprende...
[ F ] ...i marciapiedi
[ F ] ...le banchine
Argomento: La carreggiata
La carreggiata è...
[ F ] ...destinata soltanto alla circolazione di carri a trazione animale
[ V ] ...la parte della strada destinata normalmente alla circolazione dei veicoli
[ F ] ...destinata alla sosta degli autocarri
[ F ] ...la traccia lasciata dalle ruote dei veicoli sulle strade innevate
[ F ] ...destinata alla sosta di emergenza
La carreggiata può...
[ V ] ...essere a senso unico di circolazione
[ V ] ...essere suddivisa in corsie
[ V ] ...essere a doppio senso di circolazione
Fanno parte della carreggiata...
[ V ] ...le corsie di sorpasso
[ V ] ...le corsie di marcia
[ V ] ...gli attraversamenti pedonali
[ V ] ...gli attraversamenti ciclabili
[ F ] ...i marciapiedi
[ F ] ...le banchine
[ F ] ...le corsie di emergenza delle autostrade
La carreggiata non comprende...
[ V ] ...le piste ciclabili
[ V ] ...i marciapiedi
Argomento: La corsia
La corsia è...
[ V ] ...limitata da strisce continue o discontinue
[ V ] ...una parte della carreggiata che consente la circolazione di una sola fila di veicoli
[ F ] ...formata da due carreggiate
[ F ] ...una strada a scorrimento veloce
[ F ] ...destinata solo al transito dei pedoni
La corsia può...
[ F ] ...essere a doppio senso di circolazione
[ V ] ...essere destinata alla normale marcia dei veicoli
[ V ] ...essere destinata ad effettuare sorpassi
[ V ] ...essere riservata ai veicoli che intendono svoltare
[ V ] ...essere destinata alle soste di emergenza, in caso di guasto o malessere
La corsia di accelerazione...
[ V ] ...facilita l'ingresso dei veicoli in autostrada o su strade extraurbane principali
[ V ] ...serve ad entrare correttamente in autostrada
[ F ] ...serve per abbandonare la carreggiata dell’autostrada
[ V ] ...serve per rientrare sulla carreggiata dell’autostrada dopo un'area di servizio
[ V ] ...viene utilizzata per aumentare la velocità
La corsia di decelerazione...
[ V ] ...facilita l'uscita dei veicoli dall'autostrada
[ F ] ...può essere utilizzata per la sosta dei veicoli
[ V ] ...serve per uscire correttamente da una strada extraurbana principale
[ F ] ...serve ad entrare in autostrada
Argomento: Intersezioni
L'intersezione (incrocio) a raso...
[ V ] ...richiede di fare attenzione ai veicoli provenienti dalle strade che si incrociano
[ V ] ...è un'intersezione di due o più strade poste allo stesso livello
[ F ] ...è un passaggio a livello
[ F ] ...è un incrocio fra una strada statale e i binari del tram
[ V ] ...può essere regolata da semaforo
L'intersezione (incrocio) a livelli sfalsati...
[ V ] ...è munita di infrastrutture (rampe, sovrappassi, sottopassi)
[ V ] ...comprende strade situate ad altezze diverse
[ V ] ...facilita la circolazione, perché esclude l'incrocio diretto fra i veicoli
[ F ] ...è, di norma, regolata da semafori
Argomento: Passaggi a livello
In un passaggio a livello si possono trovare...
[ V ] ...le luci rosse
[ V ] ...le semibarriere
[ V ] ...le barriere
[ F ] ...le corsie di accelerazione
Argomento: Marciapiedi
Il marciapiede è...
[ V ] ...una parte della strada riservata, di norma, ai pedoni
[ V ] ...una parte della strada, rialzata o delimitata in altro modo, riservata ai pedoni
[ F ] ...una parte della carreggiata
[ F ] ...una parte della strada riservata anche alle biciclette
Argomento: Zona a Traffico Limitato
Una zona a traffico limitato è...
[ F ] ...un'area vietata al transito dei pedoni durante le ore notturne
[ V ] ...delimitata da appositi segnali stradali di inizio e di fine
[ V ] ...un'area nella quale può essere limitata la circolazione solo a particolari categorie di veicoli
[ V ] ...un'area in cui può essere limitata la circolazione dei veicoli solo in alcune ore
Argomento: Divieti Generali
È vietato rimuovere...
[ V ] ...la segnaletica stradale
Spostare la segnaletica...
[ V ] ...stradale può comportare pericolo grave per gli altri utenti della strada
È vietato gettare...
[ V ] ...oggetti e rifiuti dai veicoli in movimento
Su tutte le strade è vietato...
[ F ] ...il transito dei veicoli che superano 10 m di lunghezza
È vietato lanciare...
[ V ] ...dal finestrino mozziconi di sigaretta accesi
`;

        class DataParser {
            static parse(text) {
                const lines = text.split('\n');
                const levels = [];
                let currentTopic = "Generale";
                let currentRoot = null;
                let currentQuestions = [];

                lines.forEach(line => {
                    line = line.trim();
                    if (!line) return;

                    // 1. Detect Topic
                    if (line.startsWith('Argomento:') || line.startsWith('Lezione:')) {
                        currentTopic = line.replace('Argomento:', '').replace('Lezione:', '').trim();
                        return;
                    }

                    // 2. Detect Answer
                    if (line.startsWith('[ V ]') || line.startsWith('[ F ]')) {
                        if (!currentRoot) return;
                        const isTrue = line.startsWith('[ V ]');
                        // Clean the text (remove [ V ] and leading ...)
                        let txt = line.substring(5).trim();
                        if (txt.startsWith('...')) txt = txt.substring(3).trim();
                        
                        currentQuestions.push({
                            text: txt,
                            isTrue: isTrue,
                            id: Math.random().toString(36).substr(2, 9)
                        });
                    } else if (line.endsWith('...') || line.endsWith(':')) {
                        // 3. Detect Root (Question)
                        // If we have a previous grouping, save it
                        if (currentRoot && currentQuestions.length > 0) {
                            levels.push({
                                topic: currentTopic,
                                root: currentRoot,
                                answers: [...currentQuestions]
                            });
                        }
                        // Start new grouping
                        currentRoot = line;
                        currentQuestions = [];
                    }
                });

                // Push last set
                if (currentRoot && currentQuestions.length > 0) {
                    levels.push({
                        topic: currentTopic,
                        root: currentRoot,
                        answers: [...currentQuestions]
                    });
                }
                
                return levels;
            }
        }

        /* * =========================================
         * GAME ENGINE
         * =========================================
         */

        class Game {
            constructor() {
                this.container = document.getElementById('game-container');
                this.canvas = document.getElementById('connections-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // UI Elements
                this.scoreEl = document.getElementById('score-display');
                this.streakEl = document.getElementById('streak-display');
                this.barEl = document.getElementById('progress-bar');
                this.contextEl = document.getElementById('context-chip');
                this.msgOverlay = document.getElementById('msg-overlay');

                // State
                this.levels = DataParser.parse(RAW_DATA);
                this.currentLevelIndex = 0;
                this.score = 0;
                this.streak = 0;
                this.currentNodes = [];
                this.coreNode = null;
                this.activeLine = null; // { x, y } of pointer
                this.connections = []; // { from, to, type }
                this.completedTrueCount = 0;
                this.totalTrueCount = 0;

                // Physics/Animation
                this.animId = null;
                this.center = { x: window.innerWidth/2, y: window.innerHeight/2 };

                this.initListeners();
                this.startLevel();
                this.resize();
                this.loop();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.center = { x: window.innerWidth/2, y: window.innerHeight/2 };
                if (this.coreNode) {
                    this.coreNode.x = this.center.x;
                    this.coreNode.y = this.center.y;
                    this.updateDOMPos(this.coreNode);
                }
            }

            initListeners() {
                window.addEventListener('resize', () => this.resize());
                
                // Mouse/Touch for drawing line
                const handleMove = (e) => {
                    const x = e.clientX || e.touches[0].clientX;
                    const y = e.clientY || e.touches[0].clientY;
                    this.activeLine = { x, y };
                };
                
                const handleEnd = () => {
                    this.activeLine = null;
                };

                this.container.addEventListener('mousemove', handleMove);
                this.container.addEventListener('touchmove', handleMove);
                window.addEventListener('mouseup', handleEnd);
                window.addEventListener('touchend', handleEnd);
            }

            startLevel() {
                // Cleanup
                this.container.querySelectorAll('.node').forEach(el => el.remove());
                this.connections = [];
                this.currentNodes = [];

                // Pick Level (Random or Sequential)
                const levelData = this.levels[Math.floor(Math.random() * this.levels.length)];
                
                // Setup Core
                this.coreNode = this.createNode(levelData.root, true);
                this.coreNode.x = this.center.x;
                this.coreNode.y = this.center.y;
                
                this.contextEl.textContent = levelData.topic.toUpperCase();

                // Setup Options (Max 6 to avoid clutter)
                // Ensure mixed true/false
                let options = levelData.answers.sort(() => 0.5 - Math.random()).slice(0, 6);
                
                this.totalTrueCount = options.filter(o => o.isTrue).length;
                this.completedTrueCount = 0;
                
                // If no true answers in slice, force one
                if (this.totalTrueCount === 0 && levelData.answers.some(a=>a.isTrue)) {
                   options[0] = levelData.answers.find(a=>a.isTrue);
                   this.totalTrueCount = 1;
                }

                // Spawn positions (Orbit)
                const radius = Math.min(window.innerWidth, window.innerHeight) * 0.35;
                const angleStep = (2 * Math.PI) / options.length;

                options.forEach((opt, index) => {
                    const angle = index * angleStep - Math.PI/2; // Start top
                    const node = this.createNode(opt.text, false, opt);
                    
                    // Initial Position
                    node.x = this.center.x + Math.cos(angle) * radius;
                    node.y = this.center.y + Math.sin(angle) * radius;
                    
                    // Animation props
                    node.baseAngle = angle;
                    node.radius = radius;
                    node.floatOffset = Math.random() * 100;
                    
                    this.currentNodes.push(node);
                });

                this.updateProgressBar();
            }

            createNode(text, isCore, data = null) {
                const el = document.createElement('div');
                el.className = isCore ? 'node node-core' : 'node node-option';
                el.textContent = text;
                
                const nodeObj = {
                    el, 
                    x: 0, 
                    y: 0, 
                    isCore,
                    data, 
                    connected: false
                };

                if (isCore) {
                    // Interaction: Start drag
                    const startDrag = (e) => {
                        e.preventDefault();
                        const x = e.clientX || e.touches[0].clientX;
                        const y = e.clientY || e.touches[0].clientY;
                        this.activeLine = { x, y };
                    };
                    el.addEventListener('mousedown', startDrag);
                    el.addEventListener('touchstart', startDrag);
                } else {
                    // Interaction: Receive drop
                    const handleHit = () => this.checkConnection(nodeObj);
                    el.addEventListener('mouseup', handleHit);
                    el.addEventListener('touchend', (e) => {
                        // For touch, we need to check if the touch ended ON this element
                        const touch = e.changedTouches[0];
                        const target = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (target === el) handleHit();
                    });
                }

                this.container.appendChild(el);
                this.updateDOMPos(nodeObj);
                return nodeObj;
            }

            checkConnection(targetNode) {
                if (!this.activeLine) return; // Must be dragging from core
                if (targetNode.connected) return; // Already done

                if (targetNode.data.isTrue) {
                    // SUCCESS
                    this.handleSuccess(targetNode);
                } else {
                    // FAILURE
                    this.handleFailure(targetNode);
                }
                
                this.activeLine = null; // Stop drawing line
            }

            handleSuccess(node) {
                node.connected = true;
                node.el.classList.add('connected');
                
                // Add permanent connection visual
                this.connections.push({ node: node });

                this.score += 10 + (this.streak * 2);
                this.streak++;
                this.completedTrueCount++;
                
                // FX
                if (navigator.vibrate) navigator.vibrate(50);
                
                // Check Level Complete
                if (this.completedTrueCount >= this.totalTrueCount) {
                    setTimeout(() => this.levelComplete(), 800);
                }
                
                this.updateUI();
            }

            handleFailure(node) {
                node.el.classList.add('wrong');
                this.streak = 0;
                this.score = Math.max(0, this.score - 5);
                
                this.showOverlay("NOPE", "error");
                if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

                setTimeout(() => {
                    node.el.classList.remove('wrong');
                }, 500);

                this.updateUI();
            }

            levelComplete() {
                this.showOverlay("COMPLETO", "success");
                setTimeout(() => {
                    this.startLevel();
                    this.msgOverlay.className = "overlay-msg"; // Hide
                }, 1500);
            }

            showOverlay(text, type) {
                this.msgOverlay.textContent = text;
                this.msgOverlay.className = `overlay-msg show text-${type}`;
                setTimeout(() => {
                    if (type === 'error') this.msgOverlay.className = "overlay-msg";
                }, 1000);
            }

            updateUI() {
                this.scoreEl.innerText = this.score;
                this.streakEl.innerText = this.streak;
                this.updateProgressBar();
            }

            updateProgressBar() {
                const pct = (this.completedTrueCount / this.totalTrueCount) * 100;
                this.barEl.style.width = `${pct}%`;
            }

            updateDOMPos(node) {
                node.el.style.transform = `translate(-50%, -50%) translate(${node.x}px, ${node.y}px)`;
                // NOTE: We use translate inside transform to avoid layout thrashing with left/top
                // But since the parent is absolute inset 0, 0,0 is top left. 
                // Wait, easier approach:
                node.el.style.left = `${node.x}px`;
                node.el.style.top = `${node.y}px`;
                node.el.style.transform = `translate(-50%, -50%)`;
            }

            loop() {
                const now = Date.now();
                
                // Clear Canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Animate Floating Options
                this.currentNodes.forEach(node => {
                    if (!node.connected) {
                        // Gentle float
                        const t = now * 0.001;
                        const floatX = Math.sin(t + node.floatOffset) * 10;
                        const floatY = Math.cos(t * 0.8 + node.floatOffset) * 10;
                        
                        // Update position based on orbit + float
                        node.x = this.center.x + Math.cos(node.baseAngle) * node.radius + floatX;
                        node.y = this.center.y + Math.sin(node.baseAngle) * node.radius + floatY;
                        this.updateDOMPos(node);
                    } else {
                        // Pull closer if connected (implosion effect)
                        const targetR = node.radius * 0.6; // Get closer to core
                        const dx = (this.center.x + Math.cos(node.baseAngle) * targetR) - node.x;
                        const dy = (this.center.y + Math.sin(node.baseAngle) * targetR) - node.y;
                        node.x += dx * 0.1;
                        node.y += dy * 0.1;
                        this.updateDOMPos(node);
                    }
                });

                // Draw Connections
                // 1. Permanent (Success) connections
                this.ctx.lineWidth = 3;
                this.connections.forEach(conn => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.center.x, this.center.y);
                    this.ctx.lineTo(conn.node.x, conn.node.y);
                    this.ctx.strokeStyle = '#4ade80'; // Success Green
                    this.ctx.stroke();
                    
                    // Little particle flow
                    const t = (now % 1000) / 1000;
                    const px = this.center.x + (conn.node.x - this.center.x) * t;
                    const py = this.center.y + (conn.node.y - this.center.y) * t;
                    this.ctx.beginPath();
                    this.ctx.arc(px, py, 4, 0, Math.PI*2);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fill();
                });

                // 2. Active Drag Line
                if (this.activeLine) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.center.x, this.center.y);
                    this.ctx.lineTo(this.activeLine.x, this.activeLine.y);
                    this.ctx.strokeStyle = '#22d3ee'; // Cyan
                    this.ctx.lineCap = 'round';
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = '#22d3ee';
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }

                requestAnimationFrame(() => this.loop());
            }
        }

        // Init
        window.onload = () => {
            const game = new Game();
        };

    </script>
</body>
</html>